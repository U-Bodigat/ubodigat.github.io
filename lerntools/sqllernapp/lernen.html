<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="verify-v1" content="unique-string">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="website, lernapp, rechner, uhr, snake, description, beschreibung, u, bodigat, u:bodigat, ubodigat">
    <meta name="author" content="U:Bodigat">
    <meta name="publisher" content="U:Bodigat">
    <meta name="copyright" content="U:Bodigat">
    <meta name="description" content="Dieser Text befindet sich noch in Arbeit">
    <meta property="og:site_name" content="U:Bodigat.com">
    <meta property="og:url" content="https://ubodigat.com">
    <meta property="og:title" content="SQL Lernapp | lernen | U:Bodigat.com">
    <meta property="og:type" content="website">
    <meta property="og:description" content="Dieser Text befindet sich noch in Arbeit">
    <meta property="og:image" content="https://cdn.discordapp.com/attachments/927268634492031026/994779232129519656/UBodigat_Werbung.png">
    <meta property="og:image:secure_url" content="https://cdn.discordapp.com/attachments/927268634492031026/994779232129519656/UBodigat_Werbung.png">
    <meta property="og:image:width" content="500">
    <meta property="og:image:height" content="500">
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ubodigat.com">
    <meta property="twitter:title" content="SQL Lernapp | lernen | U:Bodigat.com">
    <meta property="twitter:description" content="Dieser Text befindet sich noch in Arbeit">
    <meta property="twitter:image" content="https://cdn.discordapp.com/attachments/927268634492031026/994779232129519656/UBodigat_Werbung.png">
    <title>SQL Lernapp | lernen | U:Bodigat.com</title>
    <link rel="icon" href="/Bilder/Wartungsarbeitenprofilbild.png" type="image/x-icon">
    <link rel="apple-touch-icon" href="https://ubodigat.com/Bilder/Wartungsarbeitenprofilbild.png" />
    <script src="/script.js"></script>
    <link rel="stylesheet" href="/lerntools/sqllernapp/style.css">
    <script src="/lerntools/sqllernapp/script.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BE1B5EZY35"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'G-BE1B5EZY35');
    </script>
    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start': new Date().getTime(),
                event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src =
                'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-WTDQC48');
    </script>
    <!-- End Google Tag Manager -->
</head>

<body id="sqllernapphintergrund">
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WTDQC48"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <nav>
        <header>
            <p><a id="überschriftlink" href="https://ubodigat.com">U:Bodigat.com</a> | SQL Lernapp | lernen </p>
            <div id="headerinput">
                <a href="/lerntools/sqllernapp/index.html"><button class="button">SQL üben</button></a>
                <!-- <a href="https://ubodigat.com/lerntools/sqllernapp/"><button class="button">SQL lernen</button></a> -->
                <a href="https://ubodigat.com/datenschutz.html" target="_blank"> <button class="button">Datenschutz</button></a>
                <a href="/lerntools/lernmenü.html"><button class="button">Zum Lernmenü</button></a>
            </div>
        </header>
    </nav>

    <main id="mainlernensql">
        <h1 id="überschriftlernen">SQL Grundlagen</h1>

        <div class="search-bar">
            <input type="text" id="searchInput" placeholder="Suche...">
            <button id="searchButton">Suchen</button>
        </div>

        <p>
            SQL (Structured Query Language) ist eine spezielle Programmiersprache, die für die Verwaltung von Daten in relationalen Datenbanken verwendet wird. Sie ermöglicht es, Daten abzurufen, einzufügen, zu aktualisieren und zu löschen. SQL ist eine unverzichtbare
            Fähigkeit für Datenbankadministratoren und Entwickler, um effizient auf Daten zuzugreifen und diese zu verwalten.
        </p>

        <h2>SQL-Befehle</h2>
        <p>
            SQL bietet eine Vielzahl von Befehlen, um verschiedene Aufgaben in einer Datenbank auszuführen. Hier sind einige der wichtigsten SQL-Befehle:
        </p>
        <ul>
            <li><strong>SELECT:</strong> Zum Abfragen von Daten aus einer Tabelle.</li>
            <li><strong>INSERT:</strong> Zum Einfügen von neuen Daten in eine Tabelle.</li>
            <li><strong>UPDATE:</strong> Zum Aktualisieren von vorhandenen Daten in einer Tabelle.</li>
            <li><strong>DELETE:</strong> Zum Löschen von Daten aus einer Tabelle.</li>
        </ul>

        <h2 id="sqlBeispiele">SQL-Beispiele</h2>
        <p>
            Hier sind einige Beispiele für SQL-Abfragen, um die Verwendung der SQL-Befehle zu verdeutlichen:
        </p>
        <pre><code>
            -- Beispiel 1: Abfrage nach Fahrern aus Deutschland
            SELECT Vorname, Nachname
            FROM Fahrer
            WHERE Land = 'Deutschland';
        </code></pre>

        <pre><code>
            -- Beispiel 2: Abfrage nach Teams mit mehr als 100 WM-Punkten
            SELECT Teamname, WM_Punkte
            FROM Teams
            WHERE WM_Punkte > 100;
        </code></pre>

        <h2 id="sqlOperatoren">SQL-Operatoren</h2>
        <p>
            SQL verwendet verschiedene Operatoren, um komplexe Abfragen durchzuführen. Hier sind einige der häufigsten SQL-Operatoren:
        </p>
        <ul>
            <li><strong>Vergleichsoperatoren:</strong> Mit <code>&lt;, &lt;=, =, &lt;&gt;, &gt;=, &gt;</code> können Vergleichsbedingungen in der WHERE-Klausel formuliert werden.</li>
            <li><strong>Logische Operatoren:</strong> Mit <code>AND, OR, NOT</code> können logische Bedingungen in der WHERE-Klausel formuliert werden.</li>
            <li><strong>Between-Operator:</strong> Der BETWEEN-Operator wird für Bereichsvergleiche verwendet.</li>
            <li><strong>Like-Operator:</strong> Mit dem LIKE-Operator können Muster für String-Vergleiche erstellt werden.</li>
            <li><strong>In-Operator:</strong> Der IN-Operator hilft, wenn Sie eine Liste von Kriterien für gesuchte Daten haben.</li>
            <li><strong>IS-Operator:</strong> Der IS-Operator wird verwendet, um nach NULL-Werten zu suchen.</li>
            <li><strong>Distinct-Operator:</strong> Mit DISTINCT können doppelte Einträge aus den Ergebnissen entfernt werden.</li>
            <li><strong>As-Operator:</strong> Mit dem AS-Operator können Sie berechneten Ergebnisspalten Namen zuweisen.</li>
        </ul>

        <h2 id="sqlSortierung">Sortierung und Begrenzung</h2>
        <p>
            Sie können die Reihenfolge der Abfrageergebnisse steuern und die Ergebnismenge begrenzen:
        </p>
        <ul>
            <li><strong>Order By:</strong> Der ORDER BY-Operator wird verwendet, um Ergebnisse nach bestimmten Kriterien zu sortieren.</li>
            <li><strong>Limit:</strong> Der LIMIT-Operator beschränkt die Anzahl der zurückgegebenen Datensätze.</li>
        </ul>

        <h2 id="sqlNull">Arbeiten mit NULL-Werten</h2>
        <p>
            NULL-Werte sind in SQL wichtig und werden oft verwendet. Der IS-Operator kann verwendet werden, um NULL-Werte zu finden.
        </p>

        <h2 id="sqlBerechnungen">Berechnungen in SQL</h2>
        <p>
            In SQL können Sie auch Berechnungen durchführen und Ergebnisspalten mit Aliasnamen versehen.
        </p>

        <h2 id="sqlDML">Data Manipulation Language (DML)</h2>
        <p>
            Zur Bearbeitung von Daten gibt es in SQL die Befehle: INSERT, UPDATE und DELETE. Diese Befehlsgruppe wird auch als DML - Data Manipulation Language bezeichnet.
        </p>
        <h3>Wie fügt man Daten in eine Tabelle ein?</h3>
        <p>
            Mit dem INSERT-Befehl kannst Du Daten in eine Tabelle einfügen. Das geht so:
        </p>
        <pre><code>
            INSERT INTO schueler VALUES (1024, 'Mueller', 'Heinz', '1988-08-14', 'Hüttenweg 6', '64536', 'Oberdorf');
            INSERT INTO Kurs VALUES ('12I34', 'Inf', 'Datenbanken', 'GK', '2004/01', 2);
            INSERT INTO Belegt VALUES (1024, '12I34', NULL);
        </code></pre>

        <p>
            Der INSERT-Befehl hat den Aufbau:
        </p>
        <pre><code>
            INSERT INTO Tabelle VALUES (Wert_1, Wert_2,... , Wert_n);
        </code></pre>

        <p>
            Beim INSERT-Befehl in der bisherigen Form musst Du immer Werte für alle Spalten angeben. Bei der zweiten Form des INSERT-Befehls ist das nicht nötig, denn hier gibst Du hinter dem Tabellennamen die einzelnen Spalten an, die einen Wert erhalten sollen.
        </p>
        <pre><code>
            INSERT INTO Tabelle(Spalte_1, Spalte_2, Spalte_3,...) VALUES (Wert_1, Wert_2, Wert_3, ...);
        </code></pre>

        <h3>Und wie ändert man Daten?</h3>
        <p>
            Dafür gibt es den UPDATE-Befehl. Auch dafür drei Beispiele:
        </p>
        <pre><code>
            UPDATE schueler SET Nachname = 'Müller' WHERE SNr = 1024;
            UPDATE Kurs SET Thema = 'Datenbanken mit SQL', Stunden = 3  WHERE KursNr = '12I34';
            UPDATE Belegt SET Punkte = 14 WHERE SNr = 1024 AND KursNr = '12I34';
        </code></pre>

        <p>
            Mit UPDATE Tabelle gibst Du an, in welcher Tabelle Daten geändert werden sollen. Mit SET Spalte = Wert gibst Du den neuen Wert für die Spalte an. Mit WHERE Bedingung wählst Du die Datensätze aus, die geändert werden sollen.
        </p>

        <p>
            Fehlt die WHERE-Bedingung, so werden alle Datensätze geändert.
        </p>

        <h3>Ab in den Mülleimer!</h3>
        <p>
            Du löschst Datensätze mit dem DELETE-Befehl. Das geht so:
        </p>
        <pre><code>
            DELETE FROM schueler WHERE SNr = 1024;
            DELETE FROM Kurs WHERE Fach = 'D';
            DELETE FROM Belegt;
        </code></pre>

        <p>
            Beim ersten DELETE-Befehl wird als WHERE-Bedingung ein Schlüsselwert angegeben. Dadurch wird genau ein Datensatz gelöscht. Beim zweiten DELETE-Befehl werden alle Deutsch-Kurse gelöscht. Beim dritten DELETE-Befehl fehlt die WHERE-Bedingung, dadurch werden
            alle Datensätze gelöscht.
        </p>

        <h2 id="sqlDDL">Data Definition Language (DDL)</h2>
        <p>
            Der Teil von SQL, mit dem Du Tabellen und Datenbanken erstellst, wird DDL - Data Definition Language genannt. Die Tabellen der Datenbank Schule kann man mit diesen CREATE-Befehlen erzeugen:
        </p>
        <pre><code>
            CREATE TABLE schueler (
                SNr INT(5) PRIMARY KEY,
                Nachname VARCHAR(40),
                Vorname VARCHAR(30),
                Geburtsdatum DATE,
                StrasseNr VARCHAR(40),
                PLZ VARCHAR(7),
                Ort VARCHAR(40)
            );

            CREATE TABLE Kurs (
                KursNr VARCHAR(10) PRIMARY KEY,
                Fach VARCHAR(5),
                Thema VARCHAR(50),
                Art ENUM('GK', 'LK'),
                Halbjahr VARCHAR(10),
                Stunden INT(1)
            );

            CREATE TABLE Belegt (
                SNr INT(5),
                KursNr VARCHAR(10),
                Punkte INT(2),
                PRIMARY KEY (SNr, KursNr)
            );
        </code></pre>

        <p>
            Mit CREATE TABLE Tabelle erhält die Tabelle einen Namen. Dann gibst Du alle Attribute der Tabelle samt ihren Datentypen an. Die Primärschlüssel kennzeichnet man mit PRIMARY KEY.
        </p>

        <p>
            Weitere Datentypen findest Du im MySQL-Handbuch.
        </p>

        <h3>Tabellen leeren und löschen</h3>
        <p>
            Mit DELETE FROM Tabelle löschst Du alle Datensätze einer Tabelle. Zum Löschen einer Tabelle nimmst Du den DROP TABLE-Befehl, z. B. DROP TABLE Kurs.
        </p>
        <h2 id="sqlWhere">WHERE - Abfrage mit Filter</h2>
        <p>
            Man kann ein Abfrageergebnis auch auf bestimmte Zeilen eingrenzen. Dazu dient die WHERE-Klausel. Sie listet die Bedingungen auf, die die gewünschten Zeilen erfüllen sollen. Sie folgt auf die FROM-Klausel. Der Fachbegriff für diese Eingrenzung ist Selektion.
        </p>
        <p>
            Die Bedingungen, die hinter WHERE angeführt werden können, bestehen wie in Programmiersprachen aus Operanden und Operatoren. Operanden können Spaltennamen sein oder konstante Werte. Einer der Operatoren ist =, der zu einem logischen WAHR ausgewertet wird,
            wenn seine Operanden gleich sind:
        </p>
        <pre><code>
                SELECT VorlNr, Titel
                FROM Vorlesung
                WHERE Titel = 'ET';
            </code></pre>
        <p>
            listet VorlNr und Titel aller derjenigen Zeilen der Tabelle Vorlesung auf, deren Titel 'ET' ist.
        </p>
        <p>
            Es hängt von den Einstellungen der Datenbank ab, ob der = Operator Groß- und Kleinschreibung beim Vergleich beachtet. Es ist aber auf jeden Fall so, dass Leerstellen am Ende einer Zeichenkette ignoriert werden.
        </p>
        <p>
            Die solchermaßen strukturierte, häufig verwendete Anweisung wird nach den Anfangsbuchstaben auch als „SFW-Block“ bezeichnet.
        </p>
        <table>
            <tr>
                <th>VorlNr</th>
                <th>Titel</th>
            </tr>
            <tr>
                <td>5001</td>
                <td>ET</td>
            </tr>
        </table>
        <p>
            Beachten Sie: SQL-Queries werden gerne einzeilig geschrieben. Damit aber die SQL-Fehlermeldung noch hilfreicher wird, kann man (zumindest beim Debugging) mehrere Zeilen benutzen. Dann steht am Ende nicht immer "at line 1", sondern die betreffende Zeile.
        </p>
        <pre><code>
                // statt einer Zeile...
                $query = 'SELECT foo,bar FROM table WHERE answer=42';
    
                // mehrere nutzen
                $query = 'SELECT 
                    foo,
                    bar
                    FROM 
                    table 
                    WHERE 
                    answer=42';
            </code></pre>

        <h2 id="sqlLike">LIKE - Abfrage mit Filter nach Inhalt</h2>
        <p>
            Ein anderer Operator ist LIKE. Er führt einen Mustervergleich durch, ähnlich der Mustersuche nach Dateinamen mit * und ?.
        </p>
        <pre><code>
                SELECT Name
                FROM Student
                WHERE Name LIKE 'F%';
            </code></pre>
        <p>
            listet die Namen aller Studenten auf, deren Name mit F beginnt (im Beispiel: Fichte und Fauler).
        </p>
        <p>
            LIKE kann mit verschiedenen Platzhaltern verwendet werden: _ steht für ein einzelnes beliebiges Zeichen, % steht für eine beliebige Zeichenfolge. Manche Datenbanksysteme bieten weitere solche Wildcard-Zeichen an, etwa für Zeichenmengen.
        </p>
        <table>
            <tr>
                <th>Name</th>
            </tr>
            <tr>
                <td>Fichte</td>
            </tr>
            <tr>
                <td>Fauler</td>
            </tr>
        </table>

        <h2 id="sqlOrderBy">ORDER BY - Abfrage mit Filter und Sortierung</h2>
        <p>
            Wenn die Ergebnisse einer Abfrage in einer bestimmten Reihenfolge erwartet werden, kann man sie sortieren lassen. Dafür fügt man am Ende des SELECT Befehl die ORDER BY Klausel an. Sie benennt die Spalten, nach deren Inhalt zu sortieren ist. Ohne weitere
            Angaben erfolgt die Sortierung aufsteigend, durch Hinzufügen des Schlüsselwortes DESC wird diese Spalte absteigend sortiert.
        </p>
        <pre><code>
                SELECT Vorname, Name, StrasseNr, Plz, Ort
                FROM Student
                WHERE Plz = '20095'
                ORDER BY Name, Vorname DESC
            </code></pre>
        <p>
            listet Vorname, Name, StrasseNr, Plz und Ort aller Studenten aus dem angegebenen Postleitzahlbereich sortiert nach Name auf. Studenten mit gleichem Nachnamen werden absteigend nach Vorname sortiert.
        </p>
        <table>
            <tr>
                <th>Vorname</th>
                <th>Name</th>
                <th>StrasseNr</th>
                <th>Plz</th>
                <th>Ort</th>
            </tr>
            <tr>
                <td>Max</td>
                <td>Muster</td>
                <td>123</td>
                <td>20095</td>
                <td>Hamburg</td>
            </tr>
            <tr>
                <td>Maria</td>
                <td>Müller</td>
                <td>456</td>
                <td>20095</td>
                <td>Hamburg</td>
            </tr>
        </table>

        <h2 id="sqlAbfrageMitVerknuepftenTabellen">Abfrage mit verknüpften Tabellen</h2>
        <p>
            Oft müssen Inhalte mehrerer Tabellen verknüpft werden. Der Fachbegriff hierfür ist Join. Dafür listet man alle benötigten Tabellen in der FROM-Klausel auf.
        </p>
        <pre><code>
                SELECT Vorlesung.VorlNr, Vorlesung.Titel, Professor.PersNr, Professor.Name
                FROM Professor, Vorlesung
                WHERE Professor.PersNr = Vorlesung.PersNr;
            </code></pre>
        <p>
            Sie können sich den Ablauf so vorstellen, dass die Datenbank nun alle möglichen Kombinationen von Professoren und Vorlesungen bildet, ein so genanntes kartesisches Produkt. Bei 10 Professoren und 20 Vorlesungen wären das 200 mögliche Kombinationen. In
            den meisten Fällen ist das nicht gewünscht – man möchte z. B. nur die Kombinationen haben, wo die Vorlesung vom Professor gehalten wird. Dafür grenzt man die Kombinationen entsprechend ein. Dies kann in der WHERE-Klausel erfolgen, einen anderen
            Weg ist der Tabellen-Operator JOIN mit der ON Bedingung.
        </p>
        <pre><code>
                SELECT Vorlesung.VorlNr, Vorlesung.Titel, Professor.PersNr, Professor.Name
                FROM Professor INNER JOIN Vorlesung
                    ON Professor.PersNr = Vorlesung.PersNr;
            </code></pre>
        <p>
            Vorsicht: Nicht alle Datenbankmanagementsysteme kennen den JOIN-Operator.
        </p>
        <p>
            Das Schlüsselwort INNER gibt an, dass nur die Zeilen aus Professor- und Vorlesung-Tabelle Verwendung finden sollen, für die die Join-Bedingung erfüllbar ist. Ein Professor, der keine Vorlesung hält, oder eine Vorlesung mit einer in Professor unbekannten
            PersId würden also nicht aufgelistet werden. So etwas wäre ein äußerer Verbund (outer join), auf den das Kapitel über JOINs eingeht.
        </p>
        <p>
            Die im Beispiel verwendeten Tabellen Professor und Vorlesung haben ein gemeinsames Attribut: PersNr. Der JOIN liefert die Kombinationen, wo Professor-Zeile und Vorlesung-Zeile in diesem Attribut übereinstimmen. Das nennt man einen natürlichen inneren
            Verbund (natural inner join). Manche DBMS, wie z. B. MySQL, unterstützen das durch das Schlüsselwort NATURAL
        </p>
        <p>
            Was das Beispiel auch zeigt, ist der Umgang mit mehrdeutigen Namen. Die Professor- und Vorlesung-Tabelle enthalten beide eine Spalte mit dem Namen PersNr. Würde man ON PersNr = PersNr schreiben, wüsste das DBMS nicht, was gemeint ist. Um das aufzulösen,
            kann man eine Spalte den Namen der Tabelle voranstellen, in der sie zu finden ist.
        </p>
        <p>
            Tabellen können nicht nur über Schlüsselfelder, sondern über beliebige Felder miteinander verknüpft werden, wie das folgende, fachlich unsinnige Beispiel zeigt:
        </p>
        <pre><code>
                SELECT Vorlesung.Titel, Professor.Name
                FROM Professor, Vorlesung
                WHERE Professor.Name <> Vorlesung.Titel
            </code></pre>
        <p>
            Der Operator
            <> bedeutet "ungleich". Die Abfrage findet Kombinationen von Professor und Vorlesung, bei denen der Name des Professors nicht mit dem Titel der Vorlesung übereinstimmt. Prof. Shangri La mit ihrer Vorlesung über Lineare Algebra (Titel: LA) würde
                nicht ausgegeben.
        </p>
        <table>
            <tr>
                <th>Titel</th>
                <th>Name</th>
            </tr>
            <tr>
                <td>ET</td>
                <td>Tesla</td>
            </tr>
            <tr>
                <td>ET</td>
                <td>Wirth</td>
            </tr>
            <tr>
                <td>ET</td>
                <td>Urlauber</td>
            </tr>
            <tr>
                <td>IT</td>
                <td>Tesla</td>
            </tr>
            <tr>
                <td>IT</td>
                <td>Wirth</td>
            </tr>
            <tr>
                <td>IT</td>
                <td>Urlauber</td>
            </tr>
            <tr>
                <td>DB</td>
                <td>Tesla</td>
            </tr>
            <tr>
                <td>DB</td>
                <td>Wirth</td>
            </tr>
            <tr>
                <td>DB</td>
                <td>Urlauber</td>
            </tr>
        </table>

        <h2 id="sqlAggregatFunktionen">COUNT & Co - Aggregat-Funktionen</h2>
        <p>
            Eine häufige Aufgabe beim Abfragen umfangreicher Datenbestände ist ihre Verdichtung. Man möchte zählen, summieren, Durchschnitte bilden, oder Minima und Maxima finden. SQL unterstützt standardmäßig genau diese fünf Operationen durch die sogenannten Aggregatfunktionen
            COUNT, SUM, AVG, MIN und MAX. Werden diese Funktionen in einer einfachen SFW-Abfrage eingesetzt, ist das Ergebnis genau eine einzige Zeile. Es ist sinnvoll, die Aggregatfunktionen mit AS zu kombinieren, um den Namen der Ergebnisspalte festzulegen.
        </p>
        <pre><code>
                SELECT COUNT(*) AS Anzahl, MAX(Name) AS MaxName FROM Professor
            </code></pre>
        <table>
            <tr>
                <th>Anzahl</th>
                <th>MaxName</th>
            </tr>
            <tr>
                <td>3</td>
                <td>Wirth</td>
            </tr>
        </table>

        <h2 id="sqlGroupBy">GROUP BY - Bilden von Teilmengen</h2>
        <p>
            Nicht immer will man alle Sätze aggregieren. Man kann auch Teilmengen bilden. Betrachten wir ein etwas umfangreicheres Beispiel:
        </p>
        <pre><code>
                SELECT StudGang AS Studiengang, COUNT(*) AS Anzahl
                FROM Student
                GROUP BY StudGang
                ORDER BY StudGang
            </code></pre>
        <table>
            <tr>
                <th>Studiengang</th>
                <th>Anzahl</th>
            </tr>
            <tr>
                <td>E-Technik</td>
                <td>2</td>
            </tr>
            <tr>
                <td>Mathematik</td>
                <td>1</td>
            </tr>
            <tr>
                <td>Physik</td>
                <td>2</td>
            </tr>
        </table>
        <p>
            Ohne Angabe einer ORDER BY Klausel ist die Reihenfolge der Sätze nicht definiert. Das Ergebnis kann aufsteigend nach den Gruppierspalten sortiert sein, aber das ist ohne ORDER BY nicht gewährleistet.
        </p>
        <p>
            Beachten Sie: Werden Aggregatfunktionen verwendet, dann dürfen in der SELECT Klausel nur solche Spalten ohne Aggregatfunktion stehen, die unter GROUP BY angegeben sind. Viele Datenbanksysteme geben einen Fehler aus, wenn man sich nicht daran hält. MySQL
            ist eine Ausnahme, es erlaubt auch die Angabe von Spalten ohne Aggregatfunktion, die nicht unter GROUP BY aufgeführt sind. Ausgegeben wird dann aber irgendein Wert dieser Spalte der für diese Gruppe ausgewählten Zeilen.
        </p>

        <h2 id="sqlDistinct">DISTINCT - Abfrage mit eindeutigen Werten</h2>
        <p>
            Eine Sonderform der Gruppierung ist das Reduzieren einer Ergebnismenge auf eindeutige Werte. Wenn man aus der im vorigen Abschnitt gezeigten, erweiterten Student-Tabelle eine Liste der belegten Studiengänge ermitteln möchte, dann ist
        </p>
        <pre><code>
                SELECT DISTINCT StudGang FROM Student
            </code></pre>
        <p>
            falsch – man möchte ja E-Technik und Physik nur einmal ausgeben. Man kann es mit GROUP BY lösen:
        </p>
        <pre><code>
                SELECT StudGang
                FROM Student
                GROUP BY StudGang
            </code></pre>
        <p>
            Aber weil das eine recht häufige Aufgabe ist, gibt es dafür das Schlüsselwort DISTINCT in der SELECT Klausel:
        </p>
        <pre><code>
                SELECT DISTINCT StudGang FROM Student
            </code></pre>
        <p>
            DISTINCT bezieht sich nicht auf eine Spalte, sondern auf die komplette Ergebniszeile. Listet man mehrere Spalten auf, werden nur die Zeilen zusammengefasst, bei denen alle Spaltenwerte gleich sind.
        </p>
        <pre><code>
                SELECT COUNT(StudGang), COUNT(DISTINCT StudGang) FROM Student
            </code></pre>
        <p>
            ermittelt zwei Werte: Die Anzahl der Studenten, für die StudGang nicht NULL ist (ohne DISTINCT) und die Anzahl von unterschiedlicher Studiengängen, die von den Studenten belegt wurden (mit DISTINCT).
        </p>

        <h2 id="sqlHaving">HAVING - Filtern von aggregierten Werten</h2>
        <p>
            Wenn man die GROUP BY Klausel einsetzt, kann die Aufgabe entstehen, dass man nur die Gruppen sehen möchte, für die ein aggregiertes Ergebnis bestimmte Bedingungen erfüllt. Beispielsweise möchte man alle Studiengänge finden, für die die Menge der eingeschriebenen
            Studenten eine Mindestmenge unterschreitet. Eine Abfrage, die die Anzahl der Studenten pro Studiengang findet, wurde bereits weiter oben gezeigt. Eine Filterung des COUNT-Ergebnisses mittels WHERE ist aber nicht möglich, weil die WHERE-Filterung
            vor der Gruppierung stattfindet. Dafür gibt es eine eigene Klausel: HAVING.
        </p>
        <pre><code>
                SELECT StudGang AS Studiengang, COUNT(*) AS Anzahl
                FROM Student
                GROUP BY StudGang
                HAVING COUNT(*) < 2
                ORDER BY StudGang
            </code></pre>
        <table>
            <tr>
                <th>Studiengang</th>
                <th>Anzahl</th>
            </tr>
            <tr>
                <td>Mathematik</td>
                <td>1</td>
            </tr>
        </table>
        <p>
            Für Mathe ist wohl etwas mehr Werbung nötig.
        </p>

        <h2 id="sqlMengenoperatoren">Mengenoperatoren: UNION, EXCEPT und INTERSECT</h2>
        <p>
            Mengenoperatoren können dazu genutzt werden, die Ergebnismengen mehrerer SELECT-Abfragen zusammenzufügen. Voraussetzung ist, dass diese SELECTs gleich viele Attribute auslesen und die Datentypen der Attribute übereinstimmen.
        </p>
        <p>
            Mengenoperator UNION:
        </p>
        <pre><code>
                SELECT userid, username, lastlogin, 'A-Forum' as Quelle
                FROM   forum1.users 
                WHERE  userlevel=9
                UNION
                SELECT userid, username, lastlogin, 'B-Forum'
                FROM   forum2.users
                WHERE  userlevel=9
                ORDER BY lastlogin
            </code></pre>
        <!-- Ergebnistabelle für UNION -->

        <p>
            Mengenoperator EXCEPT:
        </p>
        <pre><code>
                SELECT userid, username, lastlogin, 'A-Forum' as Quelle
                FROM   forum1.users 
                WHERE  userlevel=9
                EXCEPT
                SELECT userid, username, lastlogin, 'B-Forum'
                FROM   forum2.users
                WHERE  userlevel=9
            </code></pre>
        <!-- Ergebnistabelle für EXCEPT -->

        <p>
            Mengenoperator INTERSECT:
        </p>
        <pre><code>
                SELECT userid, username, lastlogin, 'A-Forum' as Quelle
                FROM   forum1.users 
                WHERE  userlevel=9
                INTERSECT
                SELECT userid, username, lastlogin, 'B-Forum'
                FROM   forum2.users
                WHERE  userlevel=9
            </code></pre>
        <!-- Ergebnistabelle für INTERSECT -->

        <p>
            Zusammenfassung der SQL-SELECT-Abfrage-Elemente:
        </p>
        <pre><code>
                SELECT [DISTINCT] Auswahlliste [AS Spaltenalias]
                FROM Quelle [ [AS] Tabellenalias]
                [WHERE Where-Klausel]
                [GROUP BY (Group-by-Attribut)+]
                [HAVING Having-Klausel]
                [ORDER BY (Sortierungsattribut [ASC|DESC])+];
            </code></pre>

        <h2 id="sqlDatensaetzeHinzufuegenAendern">Datensätze hinzufügen und ändern</h2>
        <h3 id="sqlInsertInto">INSERT INTO</h3>
        <p>
            Mit INSERT können Sie neue Datensätze hinzufügen:
        </p>
        <pre><code>
                INSERT INTO <Tabellenname>(<Spaltenname> [, weitere Spaltennamen])
                VALUES (<Wert für die erste Spalte> [, weitere Werte])
            </code></pre>
        <p>
            Beispiel:
        </p>
        <pre><code>
                INSERT INTO Professor (PersNr, Name) 
                VALUES (21, 'Hastig')
            </code></pre>
        <p>
            Einfügen mehrerer Zeilen:
        </p>
        <pre><code>
                INSERT INTO <Tabellenname>(<Spaltenname> [, weitere Spaltennamen])
                SELECT <Spalte-1> [, weitere Ausgaben]
                [FROM ...]
                [WHERE ...]
                [GROUP BY ...]
                [HAVING ...]
            </code></pre>

        <h3 id="sqlUpdate">UPDATE</h3>
        <p>
            Mit UPDATE können Sie Werte innerhalb eines vorhandenen Datensatzes aktualisieren:
        </p>
        <pre><code>
                UPDATE tabellen_name 
                SET tabellen_spalte = wert1 
                WHERE tabellen_spalte = wert2
            </code></pre>
        <p>
            Beachten Sie, dass ohne Angabe eines WHERE-Blocks alle Datensätze geändert werden.
        </p>

        <h3 id="sqlDelete">DELETE</h3>
        <p>
            Mit DELETE können Sie Werte innerhalb eines vorhandenen Datensatzes löschen:
        </p>
        <pre><code>
                DELETE FROM tabellen_name 
                WHERE spalten_name = wert
            </code></pre>
        <p>
            Beachten Sie, dass ohne Angabe eines WHERE-Blocks alle Datensätze gelöscht werden.
        </p>

        <h2 id="sqlTabellenErzeugen">Tabellen erzeugen</h2>
        <p>
            In den vorhergehenden Kapiteln wurden bestehende Datenbanken ausgelesen und erweitert. Die Datenbanktabellen können mit Programmen wie phpMyAdmin oder auch mit SQL selbst angelegt werden.
        </p>
        <p>
            Achtung! Das Löschen, aber auch das Anlegen von Tabellen kann (durch Überschreiben bestehender Tabellen) zu Datenverlust führen. Legen Sie regelmäßig Backups an!
        </p>

        <h3 id="sqlCreate">CREATE TABLE</h3>
        <pre><code>
                CREATE TABLE tabellennamen
                (
                   Spaltenname1 datentyp1 [feldeinschränkung],
                   Spaltenname2 datentyp2 [feldeinschränkung],
                   [...]
                );
            </code></pre>
    </main>

    <div id="speaker" class="play-button">&#128266;</div>

    <script>
        const speaker = document.getElementById("speaker");
        const synth = window.speechSynthesis;
        let isReading = false;
        let utterance = new SpeechSynthesisUtterance();
        const voices = synth.getVoices();
        utterance.voice = voices[0];

        const sqlSection = document.getElementById("mainlernensql");
        if (sqlSection) {
            speaker.style.display = "block";
        }

        function toggleSpeakerButton() {
            if (!isReading) {
                const textToRead = sqlSection.innerText;
                utterance.text = textToRead;
                synth.speak(utterance);
                isReading = true;
                speaker.classList.remove("play-button");
                speaker.classList.add("stop-button");
            } else {
                synth.cancel();
                isReading = false;
                speaker.classList.add("play-button");
                speaker.classList.remove("stop-button");
            }
        }

        speaker.addEventListener("click", toggleSpeakerButton);

        utterance.onstart = () => {
            console.log("Vorlesen gestartet");
        };

        utterance.onend = () => {
            console.log("Vorlesen beendet");
        };

        //für die suche

        document.addEventListener("DOMContentLoaded", function() {
            const searchInput = document.getElementById("searchInput");
            const searchButton = document.getElementById("searchButton");

            function searchAndHighlight() {
                const searchText = searchInput.value.toLowerCase();
                const paragraphs = document.querySelectorAll("main p");

                paragraphs.forEach(function(paragraph) {
                    const paragraphText = paragraph.innerText.toLowerCase();

                    if (paragraphText.includes(searchText)) {
                        paragraph.classList.add("highlight");
                        paragraph.scrollIntoView({
                            behavior: "smooth",
                            block: "center", // Das Wort wird in der Mitte des Bildschirms positioniert
                        });
                    } else {
                        paragraph.classList.remove("highlight");
                    }
                });
            }

            searchButton.addEventListener("click", searchAndHighlight);

            searchInput.addEventListener("keydown", function(event) {
                if (event.key === "Enter") {
                    searchAndHighlight();
                    event.preventDefault();
                }
            });
        });
    </script>

</body>

</html>